// Code generated by girgen. DO NOT EDIT.

package secret

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsecret/secret.h>
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.secret_collection_create_flags_get_type()), F: marshalCollectionCreateFlags},
		{T: externglib.Type(C.secret_collection_flags_get_type()), F: marshalCollectionFlags},
		{T: externglib.Type(C.secret_collection_get_type()), F: marshalCollectioner},
	})
}

// CollectionCreateFlags flags for secret_collection_create().
type CollectionCreateFlags C.guint

const (
	// CollectionCreateNone: no flags.
	CollectionCreateNone CollectionCreateFlags = 0b0
)

func marshalCollectionCreateFlags(p uintptr) (interface{}, error) {
	return CollectionCreateFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for CollectionCreateFlags.
func (c CollectionCreateFlags) String() string {
	if c == 0 {
		return "CollectionCreateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(20)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CollectionCreateNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("CollectionCreateFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c CollectionCreateFlags) Has(other CollectionCreateFlags) bool {
	return (c & other) == other
}

// CollectionFlags flags which determine which parts of the Collection proxy are
// initialized.
type CollectionFlags C.guint

const (
	// CollectionNone: no flags.
	CollectionNone CollectionFlags = 0b0
	// CollectionLoadItems items have or should be loaded.
	CollectionLoadItems CollectionFlags = 0b10
)

func marshalCollectionFlags(p uintptr) (interface{}, error) {
	return CollectionFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for CollectionFlags.
func (c CollectionFlags) String() string {
	if c == 0 {
		return "CollectionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(34)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CollectionNone:
			builder.WriteString("None|")
		case CollectionLoadItems:
			builder.WriteString("LoadItems|")
		default:
			builder.WriteString(fmt.Sprintf("CollectionFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c CollectionFlags) Has(other CollectionFlags) bool {
	return (c & other) == other
}

// Collection: proxy object representing a collection of secrets in the Secret
// Service.
type Collection struct {
	_ [0]func() // equal guard
	gio.DBusProxy
}

var (
	_ externglib.Objector = (*Collection)(nil)
)

func wrapCollection(obj *externglib.Object) *Collection {
	return &Collection{
		DBusProxy: gio.DBusProxy{
			Object: obj,
			AsyncInitable: gio.AsyncInitable{
				Object: obj,
			},
			DBusInterface: gio.DBusInterface{
				Object: obj,
			},
			Initable: gio.Initable{
				Object: obj,
			},
		},
	}
}

func marshalCollectioner(p uintptr) (interface{}, error) {
	return wrapCollection(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Delete this collection.
//
// This method returns immediately and completes asynchronously. The secret
// service may prompt the user. secret_service_prompt() will be used to handle
// any prompts that show up.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - callback (optional): called when the operation completes.
//
func (self *Collection) Delete(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretCollection   // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_collection_delete(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// DeleteFinish: complete operation to delete this collection.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (self *Collection) DeleteFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretCollection // out
	var _arg1 *C.GAsyncResult     // out
	var _cerr *C.GError           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_collection_delete_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DeleteSync: delete this collection.
//
// This method may block indefinitely and should not be used in user interface
// threads. The secret service may prompt the user. secret_service_prompt() will
// be used to handle any prompts that show up.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//
func (self *Collection) DeleteSync(ctx context.Context) error {
	var _arg0 *C.SecretCollection // out
	var _arg1 *C.GCancellable     // out
	var _cerr *C.GError           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.secret_collection_delete_sync(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Created: get the created date and time of the collection. The return value is
// the number of seconds since the unix epoch, January 1st 1970.
//
// The function returns the following values:
//
//    - guint64: created date and time.
//
func (self *Collection) Created() uint64 {
	var _arg0 *C.SecretCollection // out
	var _cret C.guint64           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))

	_cret = C.secret_collection_get_created(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Flags: get the flags representing what features of the Collection proxy have
// been initialized.
//
// Use secret_collection_load_items() to initialize further features and change
// the flags.
//
// The function returns the following values:
//
//    - collectionFlags flags for features initialized.
//
func (self *Collection) Flags() CollectionFlags {
	var _arg0 *C.SecretCollection     // out
	var _cret C.SecretCollectionFlags // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))

	_cret = C.secret_collection_get_flags(_arg0)
	runtime.KeepAlive(self)

	var _collectionFlags CollectionFlags // out

	_collectionFlags = CollectionFlags(_cret)

	return _collectionFlags
}

// Items: get the list of items in this collection.
//
// The function returns the following values:
//
//    - list of items, when done, the list should be freed with g_list_free, and
//      each item should be released with g_object_unref().
//
func (self *Collection) Items() []Item {
	var _arg0 *C.SecretCollection // out
	var _cret *C.GList            // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))

	_cret = C.secret_collection_get_items(_arg0)
	runtime.KeepAlive(self)

	var _list []Item // out

	_list = make([]Item, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SecretItem)(v)
		var dst Item // out
		dst = *wrapItem(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Label: get the label of this collection.
//
// The function returns the following values:
//
//    - utf8: label, which should be freed with g_free().
//
func (self *Collection) Label() string {
	var _arg0 *C.SecretCollection // out
	var _cret *C.gchar            // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))

	_cret = C.secret_collection_get_label(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Locked: get whether the collection is locked or not.
//
// Use secret_service_lock() or secret_service_unlock() to lock or unlock the
// collection.
//
// The function returns the following values:
//
//    - ok: whether the collection is locked or not.
//
func (self *Collection) Locked() bool {
	var _arg0 *C.SecretCollection // out
	var _cret C.gboolean          // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))

	_cret = C.secret_collection_get_locked(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modified: get the modified date and time of the collection. The return value
// is the number of seconds since the unix epoch, January 1st 1970.
//
// The function returns the following values:
//
//    - guint64: modified date and time.
//
func (self *Collection) Modified() uint64 {
	var _arg0 *C.SecretCollection // out
	var _cret C.guint64           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))

	_cret = C.secret_collection_get_modified(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Service: get the Secret Service object that this collection was created with.
//
// The function returns the following values:
//
//    - service: secret Service object.
//
func (self *Collection) Service() *Service {
	var _arg0 *C.SecretCollection // out
	var _cret *C.SecretService    // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))

	_cret = C.secret_collection_get_service(_arg0)
	runtime.KeepAlive(self)

	var _service *Service // out

	_service = wrapService(externglib.Take(unsafe.Pointer(_cret)))

	return _service
}

// LoadItems: ensure that the Collection proxy has loaded all the items present
// in the Secret Service. This affects the result of
// secret_collection_get_items().
//
// For collections returned from secret_service_get_collections() the items will
// have already been loaded.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - callback (optional): called when the operation completes.
//
func (self *Collection) LoadItems(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretCollection   // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_collection_load_items(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// LoadItemsFinish: complete an asynchronous operation to ensure that the
// Collection proxy has loaded all the items present in the Secret Service.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (self *Collection) LoadItemsFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretCollection // out
	var _arg1 *C.GAsyncResult     // out
	var _cerr *C.GError           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_collection_load_items_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadItemsSync: ensure that the Collection proxy has loaded all the items
// present in the Secret Service. This affects the result of
// secret_collection_get_items().
//
// For collections returned from secret_service_get_collections() the items will
// have already been loaded.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//
func (self *Collection) LoadItemsSync(ctx context.Context) error {
	var _arg0 *C.SecretCollection // out
	var _arg1 *C.GCancellable     // out
	var _cerr *C.GError           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.secret_collection_load_items_sync(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Refresh the properties on this collection. This fires off a request to
// refresh, and the properties will be updated later.
//
// Calling this method is not normally necessary, as the secret service will
// notify the client when properties change.
func (self *Collection) Refresh() {
	var _arg0 *C.SecretCollection // out

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))

	C.secret_collection_refresh(_arg0)
	runtime.KeepAlive(self)
}

// Search for items matching the attributes in the collection. The attributes
// should be a table of string keys and string values.
//
// If SECRET_SEARCH_ALL is set in flags, then all the items matching the search
// will be returned. Otherwise only the first item will be returned. This is
// almost always the unlocked item that was most recently stored.
//
// If SECRET_SEARCH_UNLOCK is set in flags, then items will be unlocked if
// necessary. In either case, locked and unlocked items will match the search
// and be returned. If the unlock fails, the search does not fail.
//
// If SECRET_SEARCH_LOAD_SECRETS is set in flags, then the items will have their
// secret values loaded and available via secret_item_get_secret().
//
// This function returns immediately and completes asynchronously.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - schema (optional) for the attributes.
//    - attributes: search for items matching these attributes.
//    - flags: search option flags.
//    - callback (optional): called when the operation completes.
//
func (self *Collection) Search(ctx context.Context, schema *Schema, attributes map[string]string, flags SearchFlags, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretCollection   // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.SecretSchema       // out
	var _arg2 *C.GHashTable         // out
	var _arg3 C.SecretSearchFlags   // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	_arg3 = C.SecretSearchFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_collection_search(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// SearchFinish: complete asynchronous operation to search for items in a
// collection.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to callback.
//
// The function returns the following values:
//
//    - list: a list of items that matched the search.
//
func (self *Collection) SearchFinish(result gio.AsyncResulter) ([]Item, error) {
	var _arg0 *C.SecretCollection // out
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.GList            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_collection_search_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _list []Item // out
	var _goerr error // out

	_list = make([]Item, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SecretItem)(v)
		var dst Item // out
		dst = *wrapItem(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SearchSync: search for items matching the attributes in the collection. The
// attributes should be a table of string keys and string values.
//
// If SECRET_SEARCH_ALL is set in flags, then all the items matching the search
// will be returned. Otherwise only the first item will be returned. This is
// almost always the unlocked item that was most recently stored.
//
// If SECRET_SEARCH_UNLOCK is set in flags, then items will be unlocked if
// necessary. In either case, locked and unlocked items will match the search
// and be returned. If the unlock fails, the search does not fail.
//
// If SECRET_SEARCH_LOAD_SECRETS is set in flags, then the items will have their
// secret values loaded and available via secret_item_get_secret().
//
// This function may block indefinitely. Use the asynchronous version in user
// interface threads.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - schema (optional) for the attributes.
//    - attributes: search for items matching these attributes.
//    - flags: search option flags.
//
// The function returns the following values:
//
//    - list: a list of items that matched the search.
//
func (self *Collection) SearchSync(ctx context.Context, schema *Schema, attributes map[string]string, flags SearchFlags) ([]Item, error) {
	var _arg0 *C.SecretCollection // out
	var _arg4 *C.GCancellable     // out
	var _arg1 *C.SecretSchema     // out
	var _arg2 *C.GHashTable       // out
	var _arg3 C.SecretSearchFlags // out
	var _cret *C.GList            // in
	var _cerr *C.GError           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	_arg3 = C.SecretSearchFlags(flags)

	_cret = C.secret_collection_search_sync(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)

	var _list []Item // out
	var _goerr error // out

	_list = make([]Item, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SecretItem)(v)
		var dst Item // out
		dst = *wrapItem(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SetLabel: set the label of this collection.
//
// This function returns immediately and completes asynchronously.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - label: new label.
//    - callback (optional): called when the operation completes.
//
func (self *Collection) SetLabel(ctx context.Context, label string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretCollection   // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_collection_set_label(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(label)
	runtime.KeepAlive(callback)
}

// SetLabelFinish: complete asynchronous operation to set the label of this
// collection.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to callback.
//
func (self *Collection) SetLabelFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretCollection // out
	var _arg1 *C.GAsyncResult     // out
	var _cerr *C.GError           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_collection_set_label_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetLabelSync: set the label of this collection.
//
// This function may block indefinitely. Use the asynchronous version in user
// interface threads.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - label: new label.
//
func (self *Collection) SetLabelSync(ctx context.Context, label string) error {
	var _arg0 *C.SecretCollection // out
	var _arg2 *C.GCancellable     // out
	var _arg1 *C.gchar            // out
	var _cerr *C.GError           // in

	_arg0 = (*C.SecretCollection)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))

	C.secret_collection_set_label_sync(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(label)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CollectionCreate: create a new collection in the secret service.
//
// This method returns immediately and completes asynchronously. The secret
// service may prompt the user. secret_service_prompt() will be used to handle
// any prompts that are required.
//
// An alias is a well-known tag for a collection, such as 'default' (ie: the
// default collection to store items in). This allows other applications to
// easily identify and share a collection. If you specify an alias, and a
// collection with that alias already exists, then a new collection will not be
// created. The previous one will be returned instead.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - service (optional): secret service object.
//    - label for the new collection.
//    - alias (optional) to assign to the collection.
//    - flags: currently unused.
//    - callback (optional): called when the operation completes.
//
func CollectionCreate(ctx context.Context, service *Service, label, alias string, flags CollectionCreateFlags, callback gio.AsyncReadyCallback) {
	var _arg5 *C.GCancellable               // out
	var _arg1 *C.SecretService              // out
	var _arg2 *C.gchar                      // out
	var _arg3 *C.gchar                      // out
	var _arg4 C.SecretCollectionCreateFlags // out
	var _arg6 C.GAsyncReadyCallback         // out
	var _arg7 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if service != nil {
		_arg1 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg2))
	if alias != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(alias)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.SecretCollectionCreateFlags(flags)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_collection_create(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(label)
	runtime.KeepAlive(alias)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// CollectionCreateFinish: finish operation to create a new collection in the
// secret service.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
// The function returns the following values:
//
//    - collection: new collection, which should be unreferenced with
//      g_object_unref().
//
func CollectionCreateFinish(result gio.AsyncResulter) (*Collection, error) {
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.SecretCollection // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_collection_create_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _collection *Collection // out
	var _goerr error            // out

	_collection = wrapCollection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _collection, _goerr
}

// CollectionCreateSync: create a new collection in the secret service.
//
// This method may block indefinitely and should not be used in user interface
// threads. The secret service may prompt the user. secret_service_prompt() will
// be used to handle any prompts that are required.
//
// An alias is a well-known tag for a collection, such as 'default' (ie: the
// default collection to store items in). This allows other applications to
// easily identify and share a collection. If you specify an alias, and a
// collection with that alias already exists, then a new collection will not be
// created. The previous one will be returned instead.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - service (optional): secret service object.
//    - label for the new collection.
//    - alias (optional) to assign to the collection.
//    - flags: currently unused.
//
// The function returns the following values:
//
//    - collection: new collection, which should be unreferenced with
//      g_object_unref().
//
func CollectionCreateSync(ctx context.Context, service *Service, label, alias string, flags CollectionCreateFlags) (*Collection, error) {
	var _arg5 *C.GCancellable               // out
	var _arg1 *C.SecretService              // out
	var _arg2 *C.gchar                      // out
	var _arg3 *C.gchar                      // out
	var _arg4 C.SecretCollectionCreateFlags // out
	var _cret *C.SecretCollection           // in
	var _cerr *C.GError                     // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if service != nil {
		_arg1 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg2))
	if alias != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(alias)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.SecretCollectionCreateFlags(flags)

	_cret = C.secret_collection_create_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(label)
	runtime.KeepAlive(alias)
	runtime.KeepAlive(flags)

	var _collection *Collection // out
	var _goerr error            // out

	_collection = wrapCollection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _collection, _goerr
}

// CollectionForAlias: lookup which collection is assigned to this alias.
// Aliases help determine well known collections, such as 'default'.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - service (optional): secret service object.
//    - alias to lookup.
//    - flags options for the collection initialization.
//    - callback (optional): called when the operation completes.
//
func CollectionForAlias(ctx context.Context, service *Service, alias string, flags CollectionFlags, callback gio.AsyncReadyCallback) {
	var _arg4 *C.GCancellable         // out
	var _arg1 *C.SecretService        // out
	var _arg2 *C.gchar                // out
	var _arg3 C.SecretCollectionFlags // out
	var _arg5 C.GAsyncReadyCallback   // out
	var _arg6 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if service != nil {
		_arg1 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(alias)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.SecretCollectionFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_collection_for_alias(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(alias)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// CollectionForAliasFinish: finish an asynchronous operation to lookup which
// collection is assigned to an alias.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to callback.
//
// The function returns the following values:
//
//    - collection: collection, or NULL if none assigned to the alias.
//
func CollectionForAliasFinish(result gio.AsyncResulter) (*Collection, error) {
	var _arg1 *C.GAsyncResult     // out
	var _cret *C.SecretCollection // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_collection_for_alias_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _collection *Collection // out
	var _goerr error            // out

	_collection = wrapCollection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _collection, _goerr
}

// CollectionForAliasSync: lookup which collection is assigned to this alias.
// Aliases help determine well known collections, such as 'default'.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// This method may block and should not be used in user interface threads.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellation object.
//    - service (optional): secret service object.
//    - alias to lookup.
//    - flags options for the collection initialization.
//
// The function returns the following values:
//
//    - collection: collection, or NULL if none assigned to the alias.
//
func CollectionForAliasSync(ctx context.Context, service *Service, alias string, flags CollectionFlags) (*Collection, error) {
	var _arg4 *C.GCancellable         // out
	var _arg1 *C.SecretService        // out
	var _arg2 *C.gchar                // out
	var _arg3 C.SecretCollectionFlags // out
	var _cret *C.SecretCollection     // in
	var _cerr *C.GError               // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if service != nil {
		_arg1 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(alias)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.SecretCollectionFlags(flags)

	_cret = C.secret_collection_for_alias_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(alias)
	runtime.KeepAlive(flags)

	var _collection *Collection // out
	var _goerr error            // out

	_collection = wrapCollection(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _collection, _goerr
}
