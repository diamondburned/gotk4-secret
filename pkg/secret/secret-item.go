// Code generated by girgen. DO NOT EDIT.

package secret

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libsecret-1
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <libsecret/secret.h>
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.secret_item_create_flags_get_type()), F: marshalItemCreateFlags},
		{T: externglib.Type(C.secret_item_flags_get_type()), F: marshalItemFlags},
		{T: externglib.Type(C.secret_item_get_type()), F: marshalItemmer},
	})
}

// ItemCreateFlags flags for secret_item_create().
type ItemCreateFlags int

const (
	// ItemCreateNone: no flags
	ItemCreateNone ItemCreateFlags = 0b0
	// ItemCreateReplace an item with the same attributes.
	ItemCreateReplace ItemCreateFlags = 0b10
)

func marshalItemCreateFlags(p uintptr) (interface{}, error) {
	return ItemCreateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for ItemCreateFlags.
func (i ItemCreateFlags) String() string {
	if i == 0 {
		return "ItemCreateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(32)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case ItemCreateNone:
			builder.WriteString("None|")
		case ItemCreateReplace:
			builder.WriteString("Replace|")
		default:
			builder.WriteString(fmt.Sprintf("ItemCreateFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// ItemFlags flags which determine which parts of the Item proxy are
// initialized.
type ItemFlags int

const (
	// ItemNone: no flags
	ItemNone ItemFlags = 0b0
	// ItemLoadSecret: secret has been (or should be) loaded for Item
	ItemLoadSecret ItemFlags = 0b10
)

func marshalItemFlags(p uintptr) (interface{}, error) {
	return ItemFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the names in string for ItemFlags.
func (i ItemFlags) String() string {
	if i == 0 {
		return "ItemFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(23)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case ItemNone:
			builder.WriteString("None|")
		case ItemLoadSecret:
			builder.WriteString("LoadSecret|")
		default:
			builder.WriteString(fmt.Sprintf("ItemFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Item: proxy object representing a secret item in the Secret Service.
type Item struct {
	gio.DBusProxy

	Retrievable
	*externglib.Object
}

func wrapItem(obj *externglib.Object) *Item {
	return &Item{
		DBusProxy: gio.DBusProxy{
			Object: obj,
			AsyncInitable: gio.AsyncInitable{
				Object: obj,
			},
			DBusInterface: gio.DBusInterface{
				Object: obj,
			},
			Initable: gio.Initable{
				Object: obj,
			},
		},
		Retrievable: Retrievable{
			Object: obj,
		},
		Object: obj,
	}
}

func marshalItemmer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapItem(obj), nil
}

// Delete this item.
//
// This method returns immediately and completes asynchronously. The secret
// service may prompt the user. secret_service_prompt() will be used to handle
// any prompts that show up.
func (self *Item) Delete(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretItem         // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.secret_item_delete(_arg0, _arg1, _arg2, _arg3)
}

// DeleteFinish: complete asynchronous operation to delete the secret item.
func (self *Item) DeleteFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretItem   // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_item_delete_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// DeleteSync: delete this secret item.
//
// This method may block indefinitely and should not be used in user interface
// threads. The secret service may prompt the user. secret_service_prompt() will
// be used to handle any prompts that show up.
func (self *Item) DeleteSync(ctx context.Context) error {
	var _arg0 *C.SecretItem   // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.secret_item_delete_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Attributes: set the attributes of this item.
//
// The attributes are a mapping of string keys to string values. Attributes are
// used to search for items. Attributes are not stored or transferred securely
// by the secret service.
//
// Do not modify the attributes returned by this method. Use
// secret_item_set_attributes() instead.
func (self *Item) Attributes() map[string]string {
	var _arg0 *C.SecretItem // out
	var _cret *C.GHashTable // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_attributes(_arg0)

	var _hashTable map[string]string // out

	_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.gchar)(v)
		var kdst string // out
		var vdst string // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		defer C.free(unsafe.Pointer(ksrc))
		vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
		defer C.free(unsafe.Pointer(vsrc))
		_hashTable[kdst] = vdst
	})

	return _hashTable
}

// Created: get the created date and time of the item. The return value is the
// number of seconds since the unix epoch, January 1st 1970.
func (self *Item) Created() uint64 {
	var _arg0 *C.SecretItem // out
	var _cret C.guint64     // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_created(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Flags: get the flags representing what features of the Item proxy have been
// initialized.
//
// Use secret_item_load_secret() to initialize further features and change the
// flags.
func (self *Item) Flags() ItemFlags {
	var _arg0 *C.SecretItem     // out
	var _cret C.SecretItemFlags // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_flags(_arg0)

	var _itemFlags ItemFlags // out

	_itemFlags = ItemFlags(_cret)

	return _itemFlags
}

// Label: get the label of this item.
func (self *Item) Label() string {
	var _arg0 *C.SecretItem // out
	var _cret *C.gchar      // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Locked: get whether the item is locked or not.
//
// Depending on the secret service an item may not be able to be locked
// independently from the collection that it is in.
func (self *Item) Locked() bool {
	var _arg0 *C.SecretItem // out
	var _cret C.gboolean    // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modified: get the modified date and time of the item. The return value is the
// number of seconds since the unix epoch, January 1st 1970.
func (self *Item) Modified() uint64 {
	var _arg0 *C.SecretItem // out
	var _cret C.guint64     // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_modified(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// SchemaName gets the name of the schema that this item was stored with. This
// is also available at the <literal>xdg:schema</literal> attribute.
func (self *Item) SchemaName() string {
	var _arg0 *C.SecretItem // out
	var _cret *C.gchar      // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_schema_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Secret: get the secret value of this item. If this item is locked or the
// secret has not yet been loaded then this will return NULL.
//
// To load the secret call the secret_item_load_secret() method.
func (self *Item) Secret() *Value {
	var _arg0 *C.SecretItem  // out
	var _cret *C.SecretValue // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_secret(_arg0)

	var _value *Value // out

	_value = (*Value)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.secret_value_ref(_cret)
	runtime.SetFinalizer(_value, func(v *Value) {
		C.secret_value_unref((C.gpointer)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _value
}

// Service: get the Secret Service object that this item was created with.
func (self *Item) Service() *Service {
	var _arg0 *C.SecretItem    // out
	var _cret *C.SecretService // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	_cret = C.secret_item_get_service(_arg0)

	var _service *Service // out

	_service = wrapService(externglib.Take(unsafe.Pointer(_cret)))

	return _service
}

// LoadSecret: load the secret value of this item.
//
// Each item has a single secret which might be a password or some other secret
// binary value.
//
// This function will fail if the secret item is locked.
//
// This function returns immediately and completes asynchronously.
func (self *Item) LoadSecret(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretItem         // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg3 = C.gpointer(gbox.AssignOnce(callback))

	C.secret_item_load_secret(_arg0, _arg1, _arg2, _arg3)
}

// LoadSecretFinish: complete asynchronous operation to load the secret value of
// this item.
//
// The newly loaded secret value can be accessed by calling
// secret_item_get_secret().
func (self *Item) LoadSecretFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretItem   // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_item_load_secret_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadSecretSync: load the secret value of this item.
//
// Each item has a single secret which might be a password or some other secret
// binary value.
//
// This function may block indefinitely. Use the asynchronous version in user
// interface threads.
func (self *Item) LoadSecretSync(ctx context.Context) error {
	var _arg0 *C.SecretItem   // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.secret_item_load_secret_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Refresh the properties on this item. This fires off a request to refresh, and
// the properties will be updated later.
//
// Calling this method is not normally necessary, as the secret service will
// notify the client when properties change.
func (self *Item) Refresh() {
	var _arg0 *C.SecretItem // out

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))

	C.secret_item_refresh(_arg0)
}

// SetAttributes: set the attributes of this item.
//
// The attributes are a mapping of string keys to string values. Attributes are
// used to search for items. Attributes are not stored or transferred securely
// by the secret service.
//
// This function returns immediately and completes asynchronously.
func (self *Item) SetAttributes(ctx context.Context, schema *Schema, attributes map[string]string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretItem         // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.SecretSchema       // out
	var _arg2 *C.GHashTable         // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg5 = C.gpointer(gbox.AssignOnce(callback))

	C.secret_item_set_attributes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SetAttributesFinish: complete operation to set the attributes of this item.
func (self *Item) SetAttributesFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretItem   // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_item_set_attributes_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAttributesSync: set the attributes of this item.
//
// The attributes are a mapping of string keys to string values. Attributes are
// used to search for items. Attributes are not stored or transferred securely
// by the secret service.
//
// This function may block indefinitely. Use the asynchronous version in user
// interface threads.
func (self *Item) SetAttributesSync(ctx context.Context, schema *Schema, attributes map[string]string) error {
	var _arg0 *C.SecretItem   // out
	var _arg3 *C.GCancellable // out
	var _arg1 *C.SecretSchema // out
	var _arg2 *C.GHashTable   // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)

	C.secret_item_set_attributes_sync(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetLabel: set the label of this item.
//
// This function returns immediately and completes asynchronously.
func (self *Item) SetLabel(ctx context.Context, label string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretItem         // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.secret_item_set_label(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetLabelFinish: complete asynchronous operation to set the label of this
// collection.
func (self *Item) SetLabelFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretItem   // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_item_set_label_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetLabelSync: set the label of this item.
//
// This function may block indefinitely. Use the asynchronous version in user
// interface threads.
func (self *Item) SetLabelSync(ctx context.Context, label string) error {
	var _arg0 *C.SecretItem   // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))

	C.secret_item_set_label_sync(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetSecret: set the secret value of this item.
//
// Each item has a single secret which might be a password or some other secret
// binary value.
//
// This function returns immediately and completes asynchronously.
func (self *Item) SetSecret(ctx context.Context, value *Value, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretItem         // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.SecretValue        // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SecretValue)(gextras.StructNative(unsafe.Pointer(value)))
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.secret_item_set_secret(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetSecretFinish: complete asynchronous operation to set the secret value of
// this item.
func (self *Item) SetSecretFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretItem   // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_item_set_secret_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetSecretSync: set the secret value of this item.
//
// Each item has a single secret which might be a password or some other secret
// binary value.
//
// This function may block indefinitely. Use the asynchronous version in user
// interface threads.
func (self *Item) SetSecretSync(ctx context.Context, value *Value) error {
	var _arg0 *C.SecretItem   // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.SecretValue  // out
	var _cerr *C.GError       // in

	_arg0 = (*C.SecretItem)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SecretValue)(gextras.StructNative(unsafe.Pointer(value)))

	C.secret_item_set_secret_sync(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ItemCreate: create a new item in the secret service.
//
// If the flags contains SECRET_ITEM_CREATE_REPLACE, then the secret service
// will search for an item matching the attributes, and update that item instead
// of creating a new one.
//
// This method may block indefinitely and should not be used in user interface
// threads. The secret service may prompt the user. secret_service_prompt() will
// be used to handle any prompts that are required.
func ItemCreate(ctx context.Context, collection *Collection, schema *Schema, attributes map[string]string, label string, value *Value, flags ItemCreateFlags, callback gio.AsyncReadyCallback) {
	var _arg7 *C.GCancellable         // out
	var _arg1 *C.SecretCollection     // out
	var _arg2 *C.SecretSchema         // out
	var _arg3 *C.GHashTable           // out
	var _arg4 *C.gchar                // out
	var _arg5 *C.SecretValue          // out
	var _arg6 C.SecretItemCreateFlags // out
	var _arg8 C.GAsyncReadyCallback   // out
	var _arg9 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SecretCollection)(unsafe.Pointer(collection.Native()))
	_arg2 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	_arg3 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg3, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg3)
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.SecretValue)(gextras.StructNative(unsafe.Pointer(value)))
	_arg6 = C.SecretItemCreateFlags(flags)
	_arg8 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg9 = C.gpointer(gbox.AssignOnce(callback))

	C.secret_item_create(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}

// ItemCreateFinish: finish operation to create a new item in the secret
// service.
func ItemCreateFinish(result gio.AsyncResulter) (*Item, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.SecretItem   // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_item_create_finish(_arg1, &_cerr)

	var _item *Item  // out
	var _goerr error // out

	_item = wrapItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _item, _goerr
}

// ItemCreateSync: create a new item in the secret service.
//
// If the flags contains SECRET_ITEM_CREATE_REPLACE, then the secret service
// will search for an item matching the attributes, and update that item instead
// of creating a new one.
//
// This method may block indefinitely and should not be used in user interface
// threads. The secret service may prompt the user. secret_service_prompt() will
// be used to handle any prompts that are required.
func ItemCreateSync(ctx context.Context, collection *Collection, schema *Schema, attributes map[string]string, label string, value *Value, flags ItemCreateFlags) (*Item, error) {
	var _arg7 *C.GCancellable         // out
	var _arg1 *C.SecretCollection     // out
	var _arg2 *C.SecretSchema         // out
	var _arg3 *C.GHashTable           // out
	var _arg4 *C.gchar                // out
	var _arg5 *C.SecretValue          // out
	var _arg6 C.SecretItemCreateFlags // out
	var _cret *C.SecretItem           // in
	var _cerr *C.GError               // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SecretCollection)(unsafe.Pointer(collection.Native()))
	_arg2 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	_arg3 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg3, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg3)
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.SecretValue)(gextras.StructNative(unsafe.Pointer(value)))
	_arg6 = C.SecretItemCreateFlags(flags)

	_cret = C.secret_item_create_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)

	var _item *Item  // out
	var _goerr error // out

	_item = wrapItem(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _item, _goerr
}

// ItemLoadSecrets: load the secret values for a secret item stored in the
// service.
//
// The items must all have the same SecretItem::service property.
//
// This function returns immediately and completes asynchronously.
func ItemLoadSecrets(ctx context.Context, items []Item, callback gio.AsyncReadyCallback) {
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GList              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	for i := len(items) - 1; i >= 0; i-- {
		src := items[i]
		var dst *C.SecretItem // out
		dst = (*C.SecretItem)(unsafe.Pointer((&src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
	_arg4 = C.gpointer(gbox.AssignOnce(callback))

	C.secret_item_load_secrets(_arg1, _arg2, _arg3, _arg4)
}

// ItemLoadSecretsFinish: complete asynchronous operation to load the secret
// values for secret items stored in the service.
//
// Items that are locked will not have their secrets loaded.
func ItemLoadSecretsFinish(result gio.AsyncResulter) error {
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_item_load_secrets_finish(_arg1, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ItemLoadSecretsSync: load the secret values for a secret item stored in the
// service.
//
// The items must all have the same SecretItem::service property.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// Items that are locked will not have their secrets loaded.
func ItemLoadSecretsSync(ctx context.Context, items []Item) error {
	var _arg2 *C.GCancellable // out
	var _arg1 *C.GList        // out
	var _cerr *C.GError       // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	for i := len(items) - 1; i >= 0; i-- {
		src := items[i]
		var dst *C.SecretItem // out
		dst = (*C.SecretItem)(unsafe.Pointer((&src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	C.secret_item_load_secrets_sync(_arg1, _arg2, &_cerr)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}
