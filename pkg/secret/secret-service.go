// Code generated by girgen. DO NOT EDIT.

package secret

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: libsecret-1
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <libsecret/secret.h>
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.secret_service_flags_get_type()), F: marshalServiceFlags},
		{T: externglib.Type(C.secret_service_get_type()), F: marshalServicer},
	})
}

// ServiceFlags flags which determine which parts of the Service proxy are
// initialized during a secret_service_get() or secret_service_open() operation.
type ServiceFlags C.guint

const (
	// ServiceNone: no flags for initializing the Service.
	ServiceNone ServiceFlags = 0b0
	// ServiceOpenSession: establish a session for transfer of secrets while
	// initializing the Service.
	ServiceOpenSession ServiceFlags = 0b10
	// ServiceLoadCollections: load collections while initializing the Service.
	ServiceLoadCollections ServiceFlags = 0b100
)

func marshalServiceFlags(p uintptr) (interface{}, error) {
	return ServiceFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ServiceFlags.
func (s ServiceFlags) String() string {
	if s == 0 {
		return "ServiceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(53)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case ServiceNone:
			builder.WriteString("None|")
		case ServiceOpenSession:
			builder.WriteString("OpenSession|")
		case ServiceLoadCollections:
			builder.WriteString("LoadCollections|")
		default:
			builder.WriteString(fmt.Sprintf("ServiceFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s ServiceFlags) Has(other ServiceFlags) bool {
	return (s & other) == other
}

// ServiceOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type ServiceOverrider interface {
	// CollectionGType: get the GObject type for collections instantiated by
	// this service. This will always be either Collection or derived from it.
	CollectionGType() externglib.Type
	// ItemGType: get the GObject type for items instantiated by this service.
	// This will always be either Item or derived from it.
	ItemGType() externglib.Type
	PromptAsync(ctx context.Context, prompt *Prompt, returnType *glib.VariantType, callback gio.AsyncReadyCallback)
	// PromptFinish: complete asynchronous operation to perform prompting for a
	// Prompt.
	//
	// Returns a variant result if the prompt was completed and not dismissed.
	// The type of result depends on the action the prompt is completing, and is
	// defined in the Secret Service DBus API specification.
	PromptFinish(result gio.AsyncResulter) (*glib.Variant, error)
	// PromptSync: perform prompting for a Prompt.
	//
	// Runs a prompt and performs the prompting. Returns a variant result if the
	// prompt was completed and not dismissed. The type of result depends on the
	// action the prompt is completing, and is defined in the Secret Service
	// DBus API specification.
	//
	// This function is called by other parts of this library to handle prompts
	// for the various actions that can require prompting.
	//
	// Override the ServiceClass <literal>prompt_sync</literal> virtual method
	// to change the behavior of the prompting. The default behavior is to
	// simply run secret_prompt_perform_sync() on the prompt with a NULL
	// <literal>window_id</literal>.
	PromptSync(ctx context.Context, prompt *Prompt, returnType *glib.VariantType) (*glib.Variant, error)
}

// Service: proxy object representing the Secret Service.
type Service struct {
	gio.DBusProxy
}

var (
	_ externglib.Objector = (*Service)(nil)
)

func wrapService(obj *externglib.Object) *Service {
	return &Service{
		DBusProxy: gio.DBusProxy{
			Object: obj,
			AsyncInitable: gio.AsyncInitable{
				Object: obj,
			},
			DBusInterface: gio.DBusInterface{
				Object: obj,
			},
			Initable: gio.Initable{
				Object: obj,
			},
		},
	}
}

func marshalServicer(p uintptr) (interface{}, error) {
	return wrapService(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Clear: remove unlocked items which match the attributes from the secret
// service.
//
// The attributes should be a set of key and value string pairs.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - schema for the attributes.
//    - attributes: attribute keys and values.
//    - callback: called when the operation completes.
//
func (service *Service) Clear(ctx context.Context, schema *Schema, attributes map[string]string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.SecretSchema       // out
	var _arg2 *C.GHashTable         // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_clear(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(callback)
}

// ClearFinish: finish asynchronous operation to remove items from the secret
// service.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (service *Service) ClearFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_service_clear_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ClearSync: remove unlocked items which match the attributes from the secret
// service.
//
// The attributes should be a set of key and value string pairs.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - schema for the attributes.
//    - attributes: attribute keys and values.
//
func (service *Service) ClearSync(ctx context.Context, schema *Schema, attributes map[string]string) error {
	var _arg0 *C.SecretService // out
	var _arg3 *C.GCancellable  // out
	var _arg1 *C.SecretSchema  // out
	var _arg2 *C.GHashTable    // out
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)

	C.secret_service_clear_sync(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EnsureSession: ensure that the Service proxy has established a session with
// the Secret Service. This session is used to transfer secrets.
//
// It is not normally necessary to call this method, as the session is
// established as necessary. You can also pass the SECRET_SERVICE_OPEN_SESSION
// to secret_service_get() in order to ensure that a session has been
// established by the time you get the Service proxy.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - callback: called when the operation completes.
//
func (self *Service) EnsureSession(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_ensure_session(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// EnsureSessionFinish: finish an asynchronous operation to ensure that the
// Service proxy has established a session with the Secret Service.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (self *Service) EnsureSessionFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_service_ensure_session_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EnsureSessionSync: ensure that the Service proxy has established a session
// with the Secret Service. This session is used to transfer secrets.
//
// It is not normally necessary to call this method, as the session is
// established as necessary. You can also pass the SECRET_SERVICE_OPEN_SESSION
// to secret_service_get_sync() in order to ensure that a session has been
// established by the time you get the Service proxy.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//
func (self *Service) EnsureSessionSync(ctx context.Context) error {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.secret_service_ensure_session_sync(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CollectionGType: get the GObject type for collections instantiated by this
// service. This will always be either Collection or derived from it.
func (self *Service) CollectionGType() externglib.Type {
	var _arg0 *C.SecretService // out
	var _cret C.GType          // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))

	_cret = C.secret_service_get_collection_gtype(_arg0)
	runtime.KeepAlive(self)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// Collections: get a list of Collection objects representing all the
// collections in the secret service.
//
// If the SECRET_SERVICE_LOAD_COLLECTIONS flag was not specified when
// initializing Service proxy object, then this method will return NULL. Use
// secret_service_load_collections() to load the collections.
func (self *Service) Collections() []Collection {
	var _arg0 *C.SecretService // out
	var _cret *C.GList         // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))

	_cret = C.secret_service_get_collections(_arg0)
	runtime.KeepAlive(self)

	var _list []Collection // out

	if _cret != nil {
		_list = make([]Collection, 0, gextras.ListSize(unsafe.Pointer(_cret)))
		gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
			src := (*C.SecretCollection)(v)
			var dst Collection // out
			dst = *wrapCollection(externglib.AssumeOwnership(unsafe.Pointer(src)))
			_list = append(_list, dst)
		})
	}

	return _list
}

// Flags: get the flags representing what features of the Service proxy have
// been initialized.
//
// Use secret_service_ensure_session() or secret_service_load_collections() to
// initialize further features and change the flags.
func (self *Service) Flags() ServiceFlags {
	var _arg0 *C.SecretService     // out
	var _cret C.SecretServiceFlags // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))

	_cret = C.secret_service_get_flags(_arg0)
	runtime.KeepAlive(self)

	var _serviceFlags ServiceFlags // out

	_serviceFlags = ServiceFlags(_cret)

	return _serviceFlags
}

// ItemGType: get the GObject type for items instantiated by this service. This
// will always be either Item or derived from it.
func (self *Service) ItemGType() externglib.Type {
	var _arg0 *C.SecretService // out
	var _cret C.GType          // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))

	_cret = C.secret_service_get_item_gtype(_arg0)
	runtime.KeepAlive(self)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// SessionAlgorithms: get the set of algorithms being used to transfer secrets
// between this secret service proxy and the Secret Service itself.
//
// This will be NULL if no session has been established. Use
// secret_service_ensure_session() to establish a session.
func (self *Service) SessionAlgorithms() string {
	var _arg0 *C.SecretService // out
	var _cret *C.gchar         // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))

	_cret = C.secret_service_get_session_algorithms(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// LoadCollections: ensure that the Service proxy has loaded all the collections
// present in the Secret Service. This affects the result of
// secret_service_get_collections().
//
// You can also pass the SECRET_SERVICE_LOAD_COLLECTIONS to
// secret_service_get_sync() in order to ensure that the collections have been
// loaded by the time you get the Service proxy.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - callback: called when the operation completes.
//
func (self *Service) LoadCollections(ctx context.Context, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_load_collections(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// LoadCollectionsFinish: complete an asynchronous operation to ensure that the
// Service proxy has loaded all the collections present in the Secret Service.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (self *Service) LoadCollectionsFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_service_load_collections_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadCollectionsSync: ensure that the Service proxy has loaded all the
// collections present in the Secret Service. This affects the result of
// secret_service_get_collections().
//
// You can also pass the SECRET_SERVICE_LOAD_COLLECTIONS to
// secret_service_get_sync() in order to ensure that the collections have been
// loaded by the time you get the Service proxy.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//
func (self *Service) LoadCollectionsSync(ctx context.Context) error {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.secret_service_load_collections_sync(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Lock items or collections in the secret service.
//
// The secret service may not be able to lock items individually, and may lock
// an entire collection instead.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// This method returns immediately and completes asynchronously. The secret
// service may prompt the user. secret_service_prompt() will be used to handle
// any prompts that show up.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - objects items or collections to lock.
//    - callback: called when the operation completes.
//
func (service *Service) Lock(ctx context.Context, objects []gio.DBusProxy, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GList              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	for i := len(objects) - 1; i >= 0; i-- {
		src := objects[i]
		var dst *C.GDBusProxy // out
		dst = (*C.GDBusProxy)(unsafe.Pointer((&src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_lock(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(objects)
	runtime.KeepAlive(callback)
}

// LockFinish: complete asynchronous operation to lock items or collections in
// the secret service.
//
// The secret service may not be able to lock items individually, and may lock
// an entire collection instead.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (service *Service) LockFinish(result gio.AsyncResulter) ([]gio.DBusProxy, int, error) {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 *C.GList         // in
	var _cret C.gint           // in
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_service_lock_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(result)

	var _locked []gio.DBusProxy // out
	var _gint int               // out
	var _goerr error            // out

	if _arg2 != nil {
		_locked = make([]gio.DBusProxy, 0, gextras.ListSize(unsafe.Pointer(_arg2)))
		gextras.MoveList(unsafe.Pointer(_arg2), true, func(v unsafe.Pointer) {
			src := (*C.GDBusProxy)(v)
			var dst gio.DBusProxy // out
			{
				obj := externglib.AssumeOwnership(unsafe.Pointer(src))
				dst = gio.DBusProxy{
					Object: obj,
					AsyncInitable: gio.AsyncInitable{
						Object: obj,
					},
					DBusInterface: gio.DBusInterface{
						Object: obj,
					},
					Initable: gio.Initable{
						Object: obj,
					},
				}
			}
			_locked = append(_locked, dst)
		})
	}
	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _locked, _gint, _goerr
}

// LockSync: lock items or collections in the secret service.
//
// The secret service may not be able to lock items individually, and may lock
// an entire collection instead.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// This method may block indefinitely and should not be used in user interface
// threads. The secret service may prompt the user. secret_service_prompt() will
// be used to handle any prompts that show up.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - objects items or collections to lock.
//
func (service *Service) LockSync(ctx context.Context, objects []gio.DBusProxy) ([]gio.DBusProxy, int, error) {
	var _arg0 *C.SecretService // out
	var _arg2 *C.GCancellable  // out
	var _arg1 *C.GList         // out
	var _arg3 *C.GList         // in
	var _cret C.gint           // in
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	for i := len(objects) - 1; i >= 0; i-- {
		src := objects[i]
		var dst *C.GDBusProxy // out
		dst = (*C.GDBusProxy)(unsafe.Pointer((&src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	_cret = C.secret_service_lock_sync(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(objects)

	var _locked []gio.DBusProxy // out
	var _gint int               // out
	var _goerr error            // out

	if _arg3 != nil {
		_locked = make([]gio.DBusProxy, 0, gextras.ListSize(unsafe.Pointer(_arg3)))
		gextras.MoveList(unsafe.Pointer(_arg3), true, func(v unsafe.Pointer) {
			src := (*C.GDBusProxy)(v)
			var dst gio.DBusProxy // out
			{
				obj := externglib.AssumeOwnership(unsafe.Pointer(src))
				dst = gio.DBusProxy{
					Object: obj,
					AsyncInitable: gio.AsyncInitable{
						Object: obj,
					},
					DBusInterface: gio.DBusInterface{
						Object: obj,
					},
					Initable: gio.Initable{
						Object: obj,
					},
				}
			}
			_locked = append(_locked, dst)
		})
	}
	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _locked, _gint, _goerr
}

// Lookup a secret value in the secret service.
//
// The attributes should be a set of key and value string pairs.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - schema for the attributes.
//    - attributes: attribute keys and values.
//    - callback: called when the operation completes.
//
func (service *Service) Lookup(ctx context.Context, schema *Schema, attributes map[string]string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.SecretSchema       // out
	var _arg2 *C.GHashTable         // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_lookup(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(callback)
}

// LookupFinish: finish asynchronous operation to lookup a secret value in the
// secret service.
//
// If no secret is found then NULL is returned.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (service *Service) LookupFinish(result gio.AsyncResulter) (*Value, error) {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.SecretValue   // in
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_service_lookup_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(result)

	var _value *Value // out
	var _goerr error  // out

	_value = (*Value)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_value)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.secret_value_unref((C.gpointer)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// LookupSync: lookup a secret value in the secret service.
//
// The attributes should be a set of key and value string pairs.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - schema for the attributes.
//    - attributes: attribute keys and values.
//
func (service *Service) LookupSync(ctx context.Context, schema *Schema, attributes map[string]string) (*Value, error) {
	var _arg0 *C.SecretService // out
	var _arg3 *C.GCancellable  // out
	var _arg1 *C.SecretSchema  // out
	var _arg2 *C.GHashTable    // out
	var _cret *C.SecretValue   // in
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)

	_cret = C.secret_service_lookup_sync(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)

	var _value *Value // out
	var _goerr error  // out

	_value = (*Value)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_value)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.secret_value_unref((C.gpointer)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// Prompt: perform prompting for a Prompt.
//
// This function is called by other parts of this library to handle prompts for
// the various actions that can require prompting.
//
// Override the ServiceClass <literal>prompt_async</literal> virtual method to
// change the behavior of the prompting. The default behavior is to simply run
// secret_prompt_perform() on the prompt.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - prompt: prompt.
//    - returnType: variant type of the prompt result.
//    - callback: called when the operation completes.
//
func (self *Service) Prompt(ctx context.Context, prompt *Prompt, returnType *glib.VariantType, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.SecretPrompt       // out
	var _arg2 *C.GVariantType       // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SecretPrompt)(unsafe.Pointer(prompt.Native()))
	if returnType != nil {
		_arg2 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(returnType)))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_prompt(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(prompt)
	runtime.KeepAlive(returnType)
	runtime.KeepAlive(callback)
}

// PromptFinish: complete asynchronous operation to perform prompting for a
// Prompt.
//
// Returns a variant result if the prompt was completed and not dismissed. The
// type of result depends on the action the prompt is completing, and is defined
// in the Secret Service DBus API specification.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (self *Service) PromptFinish(result gio.AsyncResulter) (*glib.Variant, error) {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GVariant      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_service_prompt_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// PromptSync: perform prompting for a Prompt.
//
// Runs a prompt and performs the prompting. Returns a variant result if the
// prompt was completed and not dismissed. The type of result depends on the
// action the prompt is completing, and is defined in the Secret Service DBus
// API specification.
//
// This function is called by other parts of this library to handle prompts for
// the various actions that can require prompting.
//
// Override the ServiceClass <literal>prompt_sync</literal> virtual method to
// change the behavior of the prompting. The default behavior is to simply run
// secret_prompt_perform_sync() on the prompt with a NULL
// <literal>window_id</literal>.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - prompt: prompt.
//    - returnType: variant type of the prompt result.
//
func (self *Service) PromptSync(ctx context.Context, prompt *Prompt, returnType *glib.VariantType) (*glib.Variant, error) {
	var _arg0 *C.SecretService // out
	var _arg2 *C.GCancellable  // out
	var _arg1 *C.SecretPrompt  // out
	var _arg3 *C.GVariantType  // out
	var _cret *C.GVariant      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.SecretService)(unsafe.Pointer(self.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.SecretPrompt)(unsafe.Pointer(prompt.Native()))
	_arg3 = (*C.GVariantType)(gextras.StructNative(unsafe.Pointer(returnType)))

	_cret = C.secret_service_prompt_sync(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(prompt)
	runtime.KeepAlive(returnType)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// Search for items matching the attributes. All collections are searched. The
// attributes should be a table of string keys and string values.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// If SECRET_SEARCH_ALL is set in flags, then all the items matching the search
// will be returned. Otherwise only the first item will be returned. This is
// almost always the unlocked item that was most recently stored.
//
// If SECRET_SEARCH_UNLOCK is set in flags, then items will be unlocked if
// necessary. In either case, locked and unlocked items will match the search
// and be returned. If the unlock fails, the search does not fail.
//
// If SECRET_SEARCH_LOAD_SECRETS is set in flags, then the items will have their
// secret values loaded and available via secret_item_get_secret().
//
// This function returns immediately and completes asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - schema for the attributes.
//    - attributes: search for items matching these attributes.
//    - flags: search option flags.
//    - callback: called when the operation completes.
//
func (service *Service) Search(ctx context.Context, schema *Schema, attributes map[string]string, flags SearchFlags, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.SecretSchema       // out
	var _arg2 *C.GHashTable         // out
	var _arg3 C.SecretSearchFlags   // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	_arg3 = C.SecretSearchFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_search(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// SearchFinish: complete asynchronous operation to search for items.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to callback.
//
func (service *Service) SearchFinish(result gio.AsyncResulter) ([]Item, error) {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GList         // in
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_service_search_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(result)

	var _list []Item // out
	var _goerr error // out

	_list = make([]Item, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SecretItem)(v)
		var dst Item // out
		dst = *wrapItem(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SearchSync: search for items matching the attributes. All collections are
// searched. The attributes should be a table of string keys and string values.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// If SECRET_SEARCH_ALL is set in flags, then all the items matching the search
// will be returned. Otherwise only the first item will be returned. This is
// almost always the unlocked item that was most recently stored.
//
// If SECRET_SEARCH_UNLOCK is set in flags, then items will be unlocked if
// necessary. In either case, locked and unlocked items will match the search
// and be returned. If the unlock fails, the search does not fail.
//
// If SECRET_SEARCH_LOAD_SECRETS is set in flags, then the items' secret values
// will be loaded for any unlocked items. Loaded item secret values are
// available via secret_item_get_secret(). If the load of a secret values fail,
// then the
//
// This function may block indefinitely. Use the asynchronous version in user
// interface threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - schema for the attributes.
//    - attributes: search for items matching these attributes.
//    - flags: search option flags.
//
func (service *Service) SearchSync(ctx context.Context, schema *Schema, attributes map[string]string, flags SearchFlags) ([]Item, error) {
	var _arg0 *C.SecretService    // out
	var _arg4 *C.GCancellable     // out
	var _arg1 *C.SecretSchema     // out
	var _arg2 *C.GHashTable       // out
	var _arg3 C.SecretSearchFlags // out
	var _cret *C.GList            // in
	var _cerr *C.GError           // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	_arg3 = C.SecretSearchFlags(flags)

	_cret = C.secret_service_search_sync(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)

	var _list []Item // out
	var _goerr error // out

	_list = make([]Item, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.SecretItem)(v)
		var dst Item // out
		dst = *wrapItem(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SetAlias: assign a collection to this alias. Aliases help determine well
// known collections, such as 'default'.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - alias to assign the collection to.
//    - collection to assign to the alias.
//    - callback: called when the operation completes.
//
func (service *Service) SetAlias(ctx context.Context, alias string, collection *Collection, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.SecretCollection   // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(alias)))
	defer C.free(unsafe.Pointer(_arg1))
	if collection != nil {
		_arg2 = (*C.SecretCollection)(unsafe.Pointer(collection.Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_set_alias(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(alias)
	runtime.KeepAlive(collection)
	runtime.KeepAlive(callback)
}

// SetAliasFinish: finish an asynchronous operation to assign a collection to an
// alias.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to callback.
//
func (service *Service) SetAliasFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_service_set_alias_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAliasSync: assign a collection to this alias. Aliases help determine well
// known collections, such as 'default'.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// This method may block and should not be used in user interface threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - alias to assign the collection to.
//    - collection to assign to the alias.
//
func (service *Service) SetAliasSync(ctx context.Context, alias string, collection *Collection) error {
	var _arg0 *C.SecretService    // out
	var _arg3 *C.GCancellable     // out
	var _arg1 *C.gchar            // out
	var _arg2 *C.SecretCollection // out
	var _cerr *C.GError           // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(alias)))
	defer C.free(unsafe.Pointer(_arg1))
	if collection != nil {
		_arg2 = (*C.SecretCollection)(unsafe.Pointer(collection.Native()))
	}

	C.secret_service_set_alias_sync(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(alias)
	runtime.KeepAlive(collection)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Store a secret value in the secret service.
//
// The attributes should be a set of key and value string pairs.
//
// If the attributes match a secret item already stored in the collection, then
// the item will be updated with these new values.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// If collection is not specified, then the default collection will be used. Use
// CRET_COLLECTION_SESSION to store the password in the session collection,
// which doesn't get stored across login sessions.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - schema to use to check attributes.
//    - attributes: attribute keys and values.
//    - collection alias, or D-Bus object path of the collection where to store
//    the secret.
//    - label for the secret.
//    - value: secret value.
//    - callback: called when the operation completes.
//
func (service *Service) Store(ctx context.Context, schema *Schema, attributes map[string]string, collection, label string, value *Value, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg6 *C.GCancellable       // out
	var _arg1 *C.SecretSchema       // out
	var _arg2 *C.GHashTable         // out
	var _arg3 *C.gchar              // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.SecretValue        // out
	var _arg7 C.GAsyncReadyCallback // out
	var _arg8 C.gpointer

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	if collection != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(collection)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.SecretValue)(gextras.StructNative(unsafe.Pointer(value)))
	if callback != nil {
		_arg7 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg8 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_store(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(collection)
	runtime.KeepAlive(label)
	runtime.KeepAlive(value)
	runtime.KeepAlive(callback)
}

// StoreFinish: finish asynchronous operation to store a secret value in the
// secret service.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (service *Service) StoreFinish(result gio.AsyncResulter) error {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.secret_service_store_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// StoreSync: store a secret value in the secret service.
//
// The attributes should be a set of key and value string pairs.
//
// If the attributes match a secret item already stored in the collection, then
// the item will be updated with these new values.
//
// If collection is NULL, then the default collection will be used. Use
// CRET_COLLECTION_SESSION to store the password in the session collection,
// which doesn't get stored across login sessions.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - schema for the attributes.
//    - attributes: attribute keys and values.
//    - collection alias, or D-Bus object path of the collection where to store
//    the secret.
//    - label for the secret.
//    - value: secret value.
//
func (service *Service) StoreSync(ctx context.Context, schema *Schema, attributes map[string]string, collection, label string, value *Value) error {
	var _arg0 *C.SecretService // out
	var _arg6 *C.GCancellable  // out
	var _arg1 *C.SecretSchema  // out
	var _arg2 *C.GHashTable    // out
	var _arg3 *C.gchar         // out
	var _arg4 *C.gchar         // out
	var _arg5 *C.SecretValue   // out
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if schema != nil {
		_arg1 = (*C.SecretSchema)(gextras.StructNative(unsafe.Pointer(schema)))
	}
	_arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.gchar // out
		var vdst *C.gchar // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
		defer C.free(unsafe.Pointer(vdst))
		C.g_hash_table_insert(_arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg2)
	if collection != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(collection)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.SecretValue)(gextras.StructNative(unsafe.Pointer(value)))

	C.secret_service_store_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(collection)
	runtime.KeepAlive(label)
	runtime.KeepAlive(value)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Unlock items or collections in the secret service.
//
// The secret service may not be able to unlock items individually, and may
// unlock an entire collection instead.
//
// If service is NULL, then secret_service_get() will be called to get the
// default Service proxy.
//
// This method may block indefinitely and should not be used in user interface
// threads. The secret service may prompt the user. secret_service_prompt() will
// be used to handle any prompts that show up.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - objects items or collections to unlock.
//    - callback: called when the operation completes.
//
func (service *Service) Unlock(ctx context.Context, objects []gio.DBusProxy, callback gio.AsyncReadyCallback) {
	var _arg0 *C.SecretService      // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GList              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	for i := len(objects) - 1; i >= 0; i-- {
		src := objects[i]
		var dst *C.GDBusProxy // out
		dst = (*C.GDBusProxy)(unsafe.Pointer((&src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_unlock(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(objects)
	runtime.KeepAlive(callback)
}

// UnlockFinish: complete asynchronous operation to unlock items or collections
// in the secret service.
//
// The secret service may not be able to unlock items individually, and may
// unlock an entire collection instead.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func (service *Service) UnlockFinish(result gio.AsyncResulter) ([]gio.DBusProxy, int, error) {
	var _arg0 *C.SecretService // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 *C.GList         // in
	var _cret C.gint           // in
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_service_unlock_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(result)

	var _unlocked []gio.DBusProxy // out
	var _gint int                 // out
	var _goerr error              // out

	if _arg2 != nil {
		_unlocked = make([]gio.DBusProxy, 0, gextras.ListSize(unsafe.Pointer(_arg2)))
		gextras.MoveList(unsafe.Pointer(_arg2), true, func(v unsafe.Pointer) {
			src := (*C.GDBusProxy)(v)
			var dst gio.DBusProxy // out
			{
				obj := externglib.AssumeOwnership(unsafe.Pointer(src))
				dst = gio.DBusProxy{
					Object: obj,
					AsyncInitable: gio.AsyncInitable{
						Object: obj,
					},
					DBusInterface: gio.DBusInterface{
						Object: obj,
					},
					Initable: gio.Initable{
						Object: obj,
					},
				}
			}
			_unlocked = append(_unlocked, dst)
		})
	}
	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _unlocked, _gint, _goerr
}

// UnlockSync: unlock items or collections in the secret service.
//
// The secret service may not be able to unlock items individually, and may
// unlock an entire collection instead.
//
// If service is NULL, then secret_service_get_sync() will be called to get the
// default Service proxy.
//
// This method may block indefinitely and should not be used in user interface
// threads. The secret service may prompt the user. secret_service_prompt() will
// be used to handle any prompts that show up.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - objects items or collections to unlock.
//
func (service *Service) UnlockSync(ctx context.Context, objects []gio.DBusProxy) ([]gio.DBusProxy, int, error) {
	var _arg0 *C.SecretService // out
	var _arg2 *C.GCancellable  // out
	var _arg1 *C.GList         // out
	var _arg3 *C.GList         // in
	var _cret C.gint           // in
	var _cerr *C.GError        // in

	if service != nil {
		_arg0 = (*C.SecretService)(unsafe.Pointer(service.Native()))
	}
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	for i := len(objects) - 1; i >= 0; i-- {
		src := objects[i]
		var dst *C.GDBusProxy // out
		dst = (*C.GDBusProxy)(unsafe.Pointer((&src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	_cret = C.secret_service_unlock_sync(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(service)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(objects)

	var _unlocked []gio.DBusProxy // out
	var _gint int                 // out
	var _goerr error              // out

	if _arg3 != nil {
		_unlocked = make([]gio.DBusProxy, 0, gextras.ListSize(unsafe.Pointer(_arg3)))
		gextras.MoveList(unsafe.Pointer(_arg3), true, func(v unsafe.Pointer) {
			src := (*C.GDBusProxy)(v)
			var dst gio.DBusProxy // out
			{
				obj := externglib.AssumeOwnership(unsafe.Pointer(src))
				dst = gio.DBusProxy{
					Object: obj,
					AsyncInitable: gio.AsyncInitable{
						Object: obj,
					},
					DBusInterface: gio.DBusInterface{
						Object: obj,
					},
					Initable: gio.Initable{
						Object: obj,
					},
				}
			}
			_unlocked = append(_unlocked, dst)
		})
	}
	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _unlocked, _gint, _goerr
}

// ServiceDisconnect: disconnect the default Service proxy returned by
// secret_service_get() and secret_service_get_sync().
//
// It is not necessary to call this function, but you may choose to do so at
// program exit. It is useful for testing that memory is not leaked.
//
// This function is safe to call at any time. But if other objects in this
// library are still referenced, then this will not result in all memory being
// freed.
func ServiceDisconnect() {
	C.secret_service_disconnect()
}

// ServiceGet: get a Service proxy for the Secret Service. If such a proxy
// object already exists, then the same proxy is returned.
//
// If flags contains any flags of which parts of the secret service to ensure
// are initialized, then those will be initialized before completing.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - flags for which service functionality to ensure is initialized.
//    - callback: called when the operation completes.
//
func ServiceGet(ctx context.Context, flags ServiceFlags, callback gio.AsyncReadyCallback) {
	var _arg2 *C.GCancellable       // out
	var _arg1 C.SecretServiceFlags  // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.SecretServiceFlags(flags)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_get(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// ServiceGetFinish: complete an asynchronous operation to get a Service proxy
// for the Secret Service.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func ServiceGetFinish(result gio.AsyncResulter) (*Service, error) {
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.SecretService // in
	var _cerr *C.GError        // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_service_get_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _service *Service // out
	var _goerr error      // out

	_service = wrapService(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _service, _goerr
}

// ServiceGetSync: get a Service proxy for the Secret Service. If such a proxy
// object already exists, then the same proxy is returned.
//
// If flags contains any flags of which parts of the secret service to ensure
// are initialized, then those will be initialized before returning.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - flags for which service functionality to ensure is initialized.
//
func ServiceGetSync(ctx context.Context, flags ServiceFlags) (*Service, error) {
	var _arg2 *C.GCancellable      // out
	var _arg1 C.SecretServiceFlags // out
	var _cret *C.SecretService     // in
	var _cerr *C.GError            // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.SecretServiceFlags(flags)

	_cret = C.secret_service_get_sync(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _service *Service // out
	var _goerr error      // out

	_service = wrapService(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _service, _goerr
}

// ServiceOpen: create a new Service proxy for the Secret Service.
//
// This function is rarely used, see secret_service_get() instead.
//
// The service_gtype argument should be set to SECRET_TYPE_SERVICE or a the type
// of a derived class.
//
// If flags contains any flags of which parts of the secret service to ensure
// are initialized, then those will be initialized before returning.
//
// If service_bus_name is NULL then the default is used.
//
// This method will return immediately and complete asynchronously.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - serviceGtype: GType of the new secret service.
//    - serviceBusName d-Bus service name of the secret service.
//    - flags for which service functionality to ensure is initialized.
//    - callback: called when the operation completes.
//
func ServiceOpen(ctx context.Context, serviceGtype externglib.Type, serviceBusName string, flags ServiceFlags, callback gio.AsyncReadyCallback) {
	var _arg4 *C.GCancellable       // out
	var _arg1 C.GType               // out
	var _arg2 *C.gchar              // out
	var _arg3 C.SecretServiceFlags  // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GType(serviceGtype)
	if serviceBusName != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(serviceBusName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.SecretServiceFlags(flags)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.secret_service_open(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(serviceGtype)
	runtime.KeepAlive(serviceBusName)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// ServiceOpenFinish: complete an asynchronous operation to create a new Service
// proxy for the Secret Service.
//
// The function takes the following parameters:
//
//    - result asynchronous result passed to the callback.
//
func ServiceOpenFinish(result gio.AsyncResulter) (*Service, error) {
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.SecretService // in
	var _cerr *C.GError        // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.secret_service_open_finish(_arg1, &_cerr)
	runtime.KeepAlive(result)

	var _service *Service // out
	var _goerr error      // out

	_service = wrapService(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _service, _goerr
}

// ServiceOpenSync: create a new Service proxy for the Secret Service.
//
// This function is rarely used, see secret_service_get_sync() instead.
//
// The service_gtype argument should be set to SECRET_TYPE_SERVICE or a the type
// of a derived class.
//
// If flags contains any flags of which parts of the secret service to ensure
// are initialized, then those will be initialized before returning.
//
// If service_bus_name is NULL then the default is used.
//
// This method may block indefinitely and should not be used in user interface
// threads.
//
// The function takes the following parameters:
//
//    - ctx: optional cancellation object.
//    - serviceGtype: GType of the new secret service.
//    - serviceBusName d-Bus service name of the secret service.
//    - flags for which service functionality to ensure is initialized.
//
func ServiceOpenSync(ctx context.Context, serviceGtype externglib.Type, serviceBusName string, flags ServiceFlags) (*Service, error) {
	var _arg4 *C.GCancellable      // out
	var _arg1 C.GType              // out
	var _arg2 *C.gchar             // out
	var _arg3 C.SecretServiceFlags // out
	var _cret *C.SecretService     // in
	var _cerr *C.GError            // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GType(serviceGtype)
	if serviceBusName != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(serviceBusName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.SecretServiceFlags(flags)

	_cret = C.secret_service_open_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(serviceGtype)
	runtime.KeepAlive(serviceBusName)
	runtime.KeepAlive(flags)

	var _service *Service // out
	var _goerr error      // out

	_service = wrapService(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _service, _goerr
}
